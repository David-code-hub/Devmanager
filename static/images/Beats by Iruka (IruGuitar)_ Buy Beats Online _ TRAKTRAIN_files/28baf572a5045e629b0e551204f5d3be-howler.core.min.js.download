/*!
 *  howler.js v2.1.3
 *  howlerjs.com
 *
 *  (c) 2013-2019, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */(function(){'use strict';/** Global Methods **/ /***************************************************************************/ /**
     * Create the global controller. All contained methods and properties apply
     * to all sounds that are currently playing or will be in the future.
     */var e=function(){this.init()};e.prototype={/**
         * Initialize the global Howler object.
         * @return {Howler}
         */init:function init(){var e=this||n;// Create a global ID counter.
return e._counter=1e3,e._html5AudioPool=[],e.html5PoolSize=10,e._codecs={},e._howls=[],e._muted=!1,e._volume=1,e._canPlayEvent="canplaythrough",e._navigator="undefined"!=typeof window&&window.navigator?window.navigator:null,e.masterGain=null,e.noAudio=!1,e.usingWebAudio=!0,e.autoSuspend=!0,e.ctx=null,e.autoUnlock=!0,e._setup(),e},/**
         * Get/set the global volume for all sounds.
         * @param  {Float} vol Volume from 0.0 to 1.0.
         * @return {Howler/Float}     Returns self or current volume.
         */volume:function volume(e){var o=this||n;if(e=parseFloat(e),o.ctx||s(),"undefined"!=typeof e&&0<=e&&1>=e){// Don't update any of the nodes if we are muted.
if(o._volume=e,o._muted)return o;// When using Web Audio, we just need to adjust the master gain.
o.usingWebAudio&&o.masterGain.gain.setValueAtTime(e,n.ctx.currentTime);// Loop through and change volume for all HTML5 audio nodes.
for(var d=0;d<o._howls.length;d++)if(!o._howls[d]._webAudio)// Get all of the sounds in this Howl group.
// Loop through all sounds and change the volumes.
for(var t,_=o._howls[d]._getSoundIds(),u=0;u<_.length;u++)t=o._howls[d]._soundById(_[u]),t&&t._node&&(t._node.volume=t._volume*e);return o}return o._volume},/**
         * Handle muting and unmuting globally.
         * @param  {Boolean} muted Is muted or not.
         */mute:function mute(e){var o=this||n;// If we don't have an AudioContext created yet, run the setup.
o.ctx||s(),o._muted=e,o.usingWebAudio&&o.masterGain.gain.setValueAtTime(e?0:o._volume,n.ctx.currentTime);// Loop through and mute all HTML5 Audio nodes.
for(var d=0;d<o._howls.length;d++)if(!o._howls[d]._webAudio)// Get all of the sounds in this Howl group.
// Loop through all sounds and mark the audio node as muted.
for(var t,_=o._howls[d]._getSoundIds(),u=0;u<_.length;u++)t=o._howls[d]._soundById(_[u]),t&&t._node&&(t._node.muted=!!e||t._muted);return o},/**
         * Unload and destroy all currently loaded Howl objects.
         * @return {Howler}
         */unload:function unload(){for(var e=this||n,o=e._howls.length-1;0<=o;o--)e._howls[o].unload();// Create a new AudioContext to make sure it is fully reset.
return e.usingWebAudio&&e.ctx&&"undefined"!=typeof e.ctx.close&&(e.ctx.close(),e.ctx=null,s()),e},/**
         * Check for codec support of specific extension.
         * @param  {String} ext Audio file extention.
         * @return {Boolean}
         */codecs:function codecs(e){return(this||n)._codecs[e.replace(/^x-/,"")]},/**
         * Setup various state values for global tracking.
         * @return {Howler}
         */_setup:function _setup(){var o=this||n;// Keeps track of the suspend/resume state of the AudioContext.
// Check if audio is available.
if(o.state=o.ctx?o.ctx.state||"suspended":"suspended",o._autoSuspend(),!o.usingWebAudio)// No audio is available on this system if noAudio is set to true.
if("undefined"!=typeof Audio)try{var d=new Audio;// Check if the canplaythrough event is available.
"undefined"==typeof d.oncanplaythrough&&(o._canPlayEvent="canplay")}catch(n){o.noAudio=!0}else o.noAudio=!0;// Test to make sure audio isn't disabled in Internet Explorer.
try{var d=new Audio;d.muted&&(o.noAudio=!0)}catch(n){}// Check for supported codecs.
return o.noAudio||o._setupCodecs(),o},/**
         * Check for browser support for various codecs and cache the results.
         * @return {Howler}
         */_setupCodecs:function _setupCodecs(){var e=this||n,o=null;// Must wrap in a try/catch because IE11 in server mode throws an error.
try{o="undefined"==typeof Audio?null:new Audio}catch(n){return e}if(!o||"function"!=typeof o.canPlayType)return e;var d=o.canPlayType("audio/mpeg;").replace(/^no$/,""),t=e._navigator&&e._navigator.userAgent.match(/OPR\/([0-6].)/g),_=t&&33>parseInt(t[0].split("/")[1],10);// Opera version <33 has mixed MP3 support, so we need to check for and block it.
return e._codecs={mp3:!!(!_&&(d||o.canPlayType("audio/mp3;").replace(/^no$/,""))),mpeg:!!d,opus:!!o.canPlayType("audio/ogg; codecs=\"opus\"").replace(/^no$/,""),ogg:!!o.canPlayType("audio/ogg; codecs=\"vorbis\"").replace(/^no$/,""),oga:!!o.canPlayType("audio/ogg; codecs=\"vorbis\"").replace(/^no$/,""),wav:!!o.canPlayType("audio/wav; codecs=\"1\"").replace(/^no$/,""),aac:!!o.canPlayType("audio/aac;").replace(/^no$/,""),caf:!!o.canPlayType("audio/x-caf;").replace(/^no$/,""),m4a:!!(o.canPlayType("audio/x-m4a;")||o.canPlayType("audio/m4a;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),mp4:!!(o.canPlayType("audio/x-mp4;")||o.canPlayType("audio/mp4;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),weba:!!o.canPlayType("audio/webm; codecs=\"vorbis\"").replace(/^no$/,""),webm:!!o.canPlayType("audio/webm; codecs=\"vorbis\"").replace(/^no$/,""),dolby:!!o.canPlayType("audio/mp4; codecs=\"ec-3\"").replace(/^no$/,""),flac:!!(o.canPlayType("audio/x-flac;")||o.canPlayType("audio/flac;")).replace(/^no$/,"")},e},/**
         * Some browsers/devices will only allow audio to be played after a user interaction.
         * Attempt to automatically unlock audio on the first user interaction.
         * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         * @return {Howler}
         */_unlockAudio:function _unlockAudio(){var o=this||n;// Only run this if Web Audio is supported and it hasn't already been unlocked.
if(!o._audioUnlocked&&o.ctx){o._audioUnlocked=!1,o.autoUnlock=!1,o._mobileUnloaded||44100===o.ctx.sampleRate||(o._mobileUnloaded=!0,o.unload()),o._scratchBuffer=o.ctx.createBuffer(1,1,22050);// Call this method on touch start to create and play a buffer,
// then check if the audio actually played to determine if
// audio has now been unlocked on iOS, Android, etc.
var d=function(){// Create a pool of unlocked HTML5 Audio objects that can
// be used for playing sounds without user interaction. HTML5
// Audio objects must be individually unlocked, as opposed
// to the WebAudio API which only needs a single activation.
// This must occur before WebAudio setup or the source.onended
// event will not fire.
for(var e=0;e<o.html5PoolSize;e++)try{var n=document.getElementById("audioplayer");//var audioNode = new Audio();
// Mark this Audio object as unlocked to ensure it can get returned
// to the unlocked pool when released.
n._unlocked=!0,o._releaseHtml5Audio(n)}catch(n){o.noAudio=!0}// Loop through any assigned audio nodes and unlock them.
for(var e=0;e<o._howls.length;e++)if(!o._howls[e]._webAudio)// Get all of the sounds in this Howl group.
// Loop through all sounds and unlock the audio nodes.
for(var t,_=o._howls[e]._getSoundIds(),u=0;u<_.length;u++)t=o._howls[e]._soundById(_[u]),t&&t._node&&!t._node._unlocked&&(t._node._unlocked=!0,t._node.load());// Fix Android can not play in suspend state.
o._autoResume();// Create an empty buffer.
var a=o.ctx.createBufferSource();a.buffer=o._scratchBuffer,a.connect(o.ctx.destination),"undefined"==typeof a.start?a.noteOn(0):a.start(0),"function"==typeof o.ctx.resume&&o.ctx.resume(),a.onended=function(){a.disconnect(0),o._audioUnlocked=!0,document.removeEventListener("touchstart",d,!0),document.removeEventListener("touchend",d,!0),document.removeEventListener("click",d,!0);// Let all sounds know that audio has been unlocked.
for(var e=0;e<o._howls.length;e++)o._howls[e]._emit("unlock")}};// Setup a touch start listener to attempt an unlock in.
return document.addEventListener("touchstart",d,!0),document.addEventListener("touchend",d,!0),document.addEventListener("click",d,!0),o}},/**
         * Get an unlocked HTML5 Audio object from the pool. If none are left,
         * return a new Audio object and throw a warning.
         * @return {Audio} HTML5 Audio object.
         */_obtainHtml5Audio:function _obtainHtml5Audio(){var e=this||n;// Return the next object from the pool if one exists.
if(e._html5AudioPool.length)return e._html5AudioPool.pop();//.Check if the audio is locked and throw a warning.
var o=new Audio().play();return o&&"undefined"!=typeof Promise&&(o instanceof Promise||"function"==typeof o.then)&&o["catch"](function(){console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")}),document.getElementById("audioplayer")||new Audio},/**
         * Return an activated HTML5 Audio object to the pool.
         * @return {Howler}
         */_releaseHtml5Audio:function _releaseHtml5Audio(e){var o=this||n;// Don't add audio to the pool if we don't know if it has been unlocked.
return e._unlocked&&o._html5AudioPool.push(e),o},/**
         * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
         * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
         * @return {Howler}
         */_autoSuspend:function _autoSuspend(){var e=this;if(e.autoSuspend&&e.ctx&&"undefined"!=typeof e.ctx.suspend&&n.usingWebAudio){// Check if any sounds are playing.
for(var o=0;o<e._howls.length;o++)if(e._howls[o]._webAudio)for(var d=0;d<e._howls[o]._sounds.length;d++)if(!e._howls[o]._sounds[d]._paused)return e;return e._suspendTimer&&clearTimeout(e._suspendTimer),e._suspendTimer=setTimeout(function(){e.autoSuspend&&(e._suspendTimer=null,e.state="suspending",e.ctx.suspend().then(function(){e.state="suspended",e._resumeAfterSuspend&&(delete e._resumeAfterSuspend,e._autoResume())}))},3e4),e}},/**
         * Automatically resume the Web Audio AudioContext when a new sound is played.
         * @return {Howler}
         */_autoResume:function _autoResume(){var e=this;if(e.ctx&&"undefined"!=typeof e.ctx.resume&&n.usingWebAudio)return"running"===e.state&&e._suspendTimer?(clearTimeout(e._suspendTimer),e._suspendTimer=null):"suspended"===e.state?(e.ctx.resume().then(function(){e.state="running";// Emit to all Howls that the audio has resumed.
for(var n=0;n<e._howls.length;n++)e._howls[n]._emit("resume")}),e._suspendTimer&&(clearTimeout(e._suspendTimer),e._suspendTimer=null)):"suspending"===e.state&&(e._resumeAfterSuspend=!0),e}};// Setup the global audio controller.
var n=new e,o=function(e){var n=this;// Throw an error if no source is provided.
return e.src&&0!==e.src.length?void n.init(e):void console.error("An array of source files must be passed with any new Howl.")};/** Group Methods **/ /***************************************************************************/ /**
     * Create an audio group controller.
     * @param {Object} o Passed in properties for this group.
     */o.prototype={/**
         * Initialize a new Howl group object.
         * @param  {Object} o Passed in properties for this group.
         * @return {Howl}
         */init:function init(e){var o=this;// If we don't have an AudioContext created yet, run the setup.
return n.ctx||s(),o._autoplay=e.autoplay||!1,o._format="string"==typeof e.format?[e.format]:e.format,o._html5=e.html5||!1,o._muted=e.mute||!1,o._loop=e.loop||!1,o._pool=e.pool||5,o._preload="boolean"!=typeof e.preload||e.preload,o._rate=e.rate||1,o._sprite=e.sprite||{},o._src="string"==typeof e.src?[e.src]:e.src,o._volume=void 0===e.volume?1:e.volume,o._xhrWithCredentials=e.xhrWithCredentials||!1,o._duration=0,o._state="unloaded",o._sounds=[],o._endTimers={},o._queue=[],o._playLock=!1,o._onend=e.onend?[{fn:e.onend}]:[],o._onfade=e.onfade?[{fn:e.onfade}]:[],o._onload=e.onload?[{fn:e.onload}]:[],o._onloaderror=e.onloaderror?[{fn:e.onloaderror}]:[],o._onplayerror=e.onplayerror?[{fn:e.onplayerror}]:[],o._onpause=e.onpause?[{fn:e.onpause}]:[],o._onplay=e.onplay?[{fn:e.onplay}]:[],o._onstop=e.onstop?[{fn:e.onstop}]:[],o._onmute=e.onmute?[{fn:e.onmute}]:[],o._onvolume=e.onvolume?[{fn:e.onvolume}]:[],o._onrate=e.onrate?[{fn:e.onrate}]:[],o._onseek=e.onseek?[{fn:e.onseek}]:[],o._onunlock=e.onunlock?[{fn:e.onunlock}]:[],o._onresume=[],o._webAudio=n.usingWebAudio&&!o._html5,"undefined"!=typeof n.ctx&&n.ctx&&n.autoUnlock&&n._unlockAudio(),n._howls.push(o),o._autoplay&&o._queue.push({event:"play",action:function action(){o.play()}}),o._preload&&o.load(),o},/**
         * Load the audio file.
         * @return {Howler}
         */load:function load(){var e=this,o=null;// If no audio is available, quit immediately.
if(n.noAudio)return void e._emit("loaderror",null,"No audio support.");// Make sure our source is in an array.
"string"==typeof e._src&&(e._src=[e._src]);// Loop through the sources and pick the first one that is compatible.
for(var t=0;t<e._src.length;t++){var u,a;if(e._format&&e._format[t])u=e._format[t];else{if(a=e._src[t],"string"!=typeof a){e._emit("loaderror",null,"Non-string found in selected audio sources - ignoring.");continue}// Extract the file extension from the URL or base64 data URI.
u=/^data:audio\/([^;,]+);/i.exec(a),u||(u=/\.([^.]+)$/.exec(a.split("?",1)[0])),u&&(u=u[1].toLowerCase())}// Log a warning if no extension was found.
// Check if this extension is available.
if(u||console.warn("No file extension was found. Consider using the \"format\" property or specify an extension."),u&&n.codecs(u)){o=e._src[t];break}}return o?(e._src=o,e._state="loading","https:"===window.location.protocol&&"http:"===o.slice(0,5)&&(e._html5=!0,e._webAudio=!1),new d(e),e._webAudio&&_(e),e):void e._emit("loaderror",null,"No codec support for selected audio sources.")},/**
         * Play a sound or resume previous playback.
         * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Number}          Sound ID.
         */play:function play(e,o){var d=this,t=null;// Determine if a sprite, sound id or nothing was passed
if("number"==typeof e)t=e,e=null;else{if("string"==typeof e&&"loaded"===d._state&&!d._sprite[e])// If the passed sprite doesn't exist, do nothing.
return null;if("undefined"==typeof e&&(e="__default",!d._playLock))// Check if there is a single paused sound that isn't ended.
// If there is, play that sound. If not, continue as usual.
{for(var _=0,u=0;u<d._sounds.length;u++)d._sounds[u]._paused&&!d._sounds[u]._ended&&(_++,t=d._sounds[u]._id);1===_?e=null:t=null}}// Get the selected node, or get one from the pool.
var a=t?d._soundById(t):d._inactiveSound();// If the sound doesn't exist, do nothing.
if(!a)return null;// Select the sprite definition.
// If the sound hasn't loaded, we must wait to get the audio's duration.
// We also need to wait to make sure we don't run into race conditions with
// the order of function calls.
if(t&&!e&&(e=a._sprite||"__default"),"loaded"!==d._state){a._sprite=e,a._ended=!1;// Add the sound to the queue to be played on load.
var r=a._id;return d._queue.push({event:"play",action:function action(){d.play(r)}}),r}// Don't play the sound if an id was passed and it is already playing.
if(t&&!a._paused)return o||d._loadQueue("play"),a._id;// Make sure the AudioContext isn't suspended, and resume it if it is.
d._webAudio&&n._autoResume();// Determine how long to play for and where to start playing.
var s=Math.max(0,0<a._seek?a._seek:d._sprite[e][0]/1e3),l=Math.max(0,(d._sprite[e][0]+d._sprite[e][1])/1e3-s),c=1e3*l/Math.abs(a._rate),p=d._sprite[e][0]/1e3,f=(d._sprite[e][0]+d._sprite[e][1])/1e3;a._sprite=e,a._ended=!1;// Update the parameters of the sound.
var m=function(){a._paused=!1,a._seek=s,a._start=p,a._stop=f,a._loop=!!(a._loop||d._sprite[e][2])};// End the sound instantly if seek is at the end.
if(s>=f)return void d._ended(a);// Begin the actual playback.
var h=a._node;if(d._webAudio){// Fire this when the sound is ready to play to begin Web Audio playback.
var g=function(){d._playLock=!1,m(),d._refreshBuffer(a);// Setup the playback params.
var e=a._muted||d._muted?0:a._volume;h.gain.setValueAtTime(e,n.ctx.currentTime),a._playStart=n.ctx.currentTime,"undefined"==typeof h.bufferSource.start?a._loop?h.bufferSource.noteGrainOn(0,s,86400):h.bufferSource.noteGrainOn(0,s,l):a._loop?h.bufferSource.start(0,s,86400):h.bufferSource.start(0,s,l),c!==1/0&&(d._endTimers[a._id]=setTimeout(d._ended.bind(d,a),c)),o||setTimeout(function(){d._emit("play",a._id),d._loadQueue()},0)};"running"===n.state?g():(d._playLock=!0,d.once("resume",g),d._clearTimer(a._id))}else{// Fire this when the sound is ready to play to begin HTML5 Audio playback.
var y=function(){h.currentTime=s,h.muted=a._muted||d._muted||n._muted||h.muted,h.volume=a._volume*n.volume(),h.playbackRate=a._rate;// Some browsers will throw an error if this is called without user interaction.
try{var t=h.play();// Support older browsers that don't support promises, and thus don't have this issue.
// If the node is still paused, then we can assume there was a playback issue.
if(t&&"undefined"!=typeof Promise&&(t instanceof Promise||"function"==typeof t.then)?(d._playLock=!0,m(),t.then(function(){d._playLock=!1,h._unlocked=!0,o||(d._emit("play",a._id),d._loadQueue())})["catch"](function(){d._playLock=!1,d._emit("playerror",a._id,"Playback was unable to start. This is most commonly an issue "+"on mobile devices and Chrome where playback was not within a user interaction."),a._ended=!0,a._paused=!0})):!o&&(d._playLock=!1,m(),d._emit("play",a._id),d._loadQueue()),h.playbackRate=a._rate,h.paused)return void d._emit("playerror",a._id,"Playback was unable to start. This is most commonly an issue "+"on mobile devices and Chrome where playback was not within a user interaction.");// Setup the end timer on sprites or listen for the ended event.
"__default"!==e||a._loop?d._endTimers[a._id]=setTimeout(d._ended.bind(d,a),c):(d._endTimers[a._id]=function(){d._ended(a),h.removeEventListener("ended",d._endTimers[a._id],!1)},h.addEventListener("ended",d._endTimers[a._id],!1))}catch(e){d._emit("playerror",a._id,e)}};// If this is streaming audio, make sure the src is set and load again.
"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"===h.src&&(h.src=d._src,h.load());// Play immediately if ready, or wait for the 'canplaythrough'e vent.
var A=window&&window.ejecta||!h.readyState&&n._navigator.isCocoonJS;if(3<=h.readyState||A)y();else{d._playLock=!0;var b=function(){y(),h.removeEventListener(n._canPlayEvent,b,!1)};h.addEventListener(n._canPlayEvent,b,!1),d._clearTimer(a._id)}}return a._id},/**
         * Pause playback and save current position.
         * @param  {Number} id The sound ID (empty to pause all in group).
         * @return {Howl}
         */pause:function pause(e){var n=this;// If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
if("loaded"!==n._state||n._playLock)return n._queue.push({event:"pause",action:function action(){n.pause(e)}}),n;// If no id is passed, get all ID's to be paused.
for(var o=n._getSoundIds(e),d=0;d<o.length;d++){n._clearTimer(o[d]);// Get the sound.
var t=n._soundById(o[d]);if(t&&!t._paused&&(t._seek=n.seek(o[d]),t._rateSeek=0,t._paused=!0,n._stopFade(o[d]),t._node))if(n._webAudio){// Make sure the sound has been created.
if(!t._node.bufferSource)continue;"undefined"==typeof t._node.bufferSource.stop?t._node.bufferSource.noteOff(0):t._node.bufferSource.stop(0),n._cleanBuffer(t._node)}else isNaN(t._node.duration)&&t._node.duration!==1/0||t._node.pause();// Fire the pause event, unless `true` is passed as the 2nd argument.
arguments[1]||n._emit("pause",t?t._id:null)}return n},/**
         * Stop playback and reset to start.
         * @param  {Number} id The sound ID (empty to stop all in group).
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Howl}
         */stop:function stop(e,n){var o=this;// If the sound hasn't loaded, add it to the load queue to stop when capable.
if("loaded"!==o._state||o._playLock)return o._queue.push({event:"stop",action:function action(){o.stop(e)}}),o;// If no id is passed, get all ID's to be stopped.
for(var d=o._getSoundIds(e),t=0;t<d.length;t++){o._clearTimer(d[t]);// Get the sound.
var _=o._soundById(d[t]);_&&(_._seek=_._start||0,_._rateSeek=0,_._paused=!0,_._ended=!0,o._stopFade(d[t]),_._node&&(o._webAudio?_._node.bufferSource&&("undefined"==typeof _._node.bufferSource.stop?_._node.bufferSource.noteOff(0):_._node.bufferSource.stop(0),o._cleanBuffer(_._node)):(!isNaN(_._node.duration)||_._node.duration===1/0)&&(_._node.currentTime=_._start||0,_._node.pause(),_._node.duration===1/0&&o._clearSound(_._node))),!n&&o._emit("stop",_._id))}return o},/**
         * Mute/unmute a single sound or all sounds in this Howl group.
         * @param  {Boolean} muted Set to true to mute and false to unmute.
         * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
         * @return {Howl}
         */mute:function mute(e,o){var d=this;// If the sound hasn't loaded, add it to the load queue to mute when capable.
if("loaded"!==d._state||d._playLock)return d._queue.push({event:"mute",action:function action(){d.mute(e,o)}}),d;// If applying mute/unmute to all sounds, update the group's value.
if("undefined"==typeof o)if("boolean"==typeof e)d._muted=e;else return d._muted;// If no id is passed, get all ID's to be muted.
for(var t,_=d._getSoundIds(o),u=0;u<_.length;u++)// Get the sound.
t=d._soundById(_[u]),t&&(t._muted=e,t._interval&&d._stopFade(t._id),d._webAudio&&t._node?t._node.gain.setValueAtTime(e?0:t._volume,n.ctx.currentTime):t._node&&(t._node.muted=!!n._muted||e),d._emit("mute",t._id));return d},/**
         * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
         *   volume() -> Returns the group's volume value.
         *   volume(id) -> Returns the sound id's current volume.
         *   volume(vol) -> Sets the volume of all sounds in this Howl group.
         *   volume(vol, id) -> Sets the volume of passed sound id.
         * @return {Howl/Number} Returns self or current volume.
         */volume:function volume(){var e,o,d=this,t=arguments;// Determine the values based on arguments.
if(0===t.length)// Return the value of the groups' volume.
return d._volume;// Update the volume or return the current volume.
if(1===t.length||2===t.length&&"undefined"==typeof t[1]){// First check if this is an ID, and if not, assume it is a new volume.
var _=d._getSoundIds(),u=_.indexOf(t[0]);0<=u?o=parseInt(t[0],10):e=parseFloat(t[0])}else 2<=t.length&&(e=parseFloat(t[0]),o=parseInt(t[1],10));var a;if("undefined"!=typeof e&&0<=e&&1>=e){// If the sound hasn't loaded, add it to the load queue to change volume when capable.
if("loaded"!==d._state||d._playLock)return d._queue.push({event:"volume",action:function action(){d.volume.apply(d,t)}}),d;// Set the group volume.
"undefined"==typeof o&&(d._volume=e),o=d._getSoundIds(o);for(var r=0;r<o.length;r++)// Get the sound.
a=d._soundById(o[r]),a&&(a._volume=e,!t[2]&&d._stopFade(o[r]),d._webAudio&&a._node&&!a._muted?a._node.gain.setValueAtTime(e,n.ctx.currentTime):a._node&&!a._muted&&(a._node.volume=e*n.volume()),d._emit("volume",a._id))}else return a=o?d._soundById(o):d._sounds[0],a?a._volume:0;return d},/**
         * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id (omit to fade all sounds).
         * @return {Howl}
         */fade:function fade(e,o,d,t){var _=this;// If the sound hasn't loaded, add it to the load queue to fade when capable.
if("loaded"!==_._state||_._playLock)return _._queue.push({event:"fade",action:function action(){_.fade(e,o,d,t)}}),_;// Make sure the to/from/len values are numbers.
e=parseFloat(e),o=parseFloat(o),d=parseFloat(d),_.volume(e,t);for(var u,a=_._getSoundIds(t),r=0;r<a.length;r++)// Create a linear fade or fall back to timeouts with HTML5 Audio.
if(u=_._soundById(a[r]),u){// If we are using Web Audio, let the native methods do the actual fade.
if(t||_._stopFade(a[r]),_._webAudio&&!u._muted){var s=n.ctx.currentTime,l=s+d/1e3;u._volume=e,u._node.gain.setValueAtTime(e,s),u._node.gain.linearRampToValueAtTime(o,l)}_._startFadeInterval(u,e,o,d,a[r],"undefined"==typeof t)}return _},/**
         * Starts the internal interval to fade a sound.
         * @param  {Object} sound Reference to sound to fade.
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id to fade.
         * @param  {Boolean} isGroup   If true, set the volume on the group.
         */_startFadeInterval:function _startFadeInterval(e,n,o,d,t,_){var u=this,a=n,i=o-n,r=Math.abs(i/.01),s=Math.max(4,0<r?d/r:d),l=Date.now();// Store the value being faded to.
// Update the volume value on each interval tick.
e._fadeTo=o,e._interval=setInterval(function(){// Update the volume based on the time since the last tick.
var t=(Date.now()-l)/d;// Make sure the volume is in the right bounds.
// Round to within 2 decimal points.
l=Date.now(),a+=i*t,a=Math.max(0,a),a=Math.min(1,a),a=Math.round(100*a)/100,u._webAudio?e._volume=a:u.volume(a,e._id,!0),_&&(u._volume=a),(o<n&&a<=o||o>n&&a>=o)&&(clearInterval(e._interval),e._interval=null,e._fadeTo=null,u.volume(o,e._id),u._emit("fade",e._id))},s)},/**
         * Internal method that stops the currently playing fade when
         * a new fade starts, volume is changed or the sound is stopped.
         * @param  {Number} id The sound id.
         * @return {Howl}
         */_stopFade:function _stopFade(e){var o=this,d=o._soundById(e);return d&&d._interval&&(o._webAudio&&d._node.gain.cancelScheduledValues(n.ctx.currentTime),clearInterval(d._interval),d._interval=null,o.volume(d._fadeTo,e),d._fadeTo=null,o._emit("fade",e)),o},/**
         * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
         *   loop() -> Returns the group's loop value.
         *   loop(id) -> Returns the sound id's loop value.
         *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
         *   loop(loop, id) -> Sets the loop value of passed sound id.
         * @return {Howl/Boolean} Returns self or current loop value.
         */loop:function(){var e,n,o,d=this,t=arguments;// Determine the values for loop and id.
if(0===t.length)// Return the grou's loop value.
return d._loop;// If no id is passed, get all ID's to be looped.
if(1!==t.length)2===t.length&&(e=t[0],n=parseInt(t[1],10));else if("boolean"==typeof t[0])e=t[0],d._loop=e;else return o=d._soundById(parseInt(t[0],10)),!!o&&o._loop;for(var _=d._getSoundIds(n),u=0;u<_.length;u++)o=d._soundById(_[u]),o&&(o._loop=e,d._webAudio&&o._node&&o._node.bufferSource&&(o._node.bufferSource.loop=e,e&&(o._node.bufferSource.loopStart=o._start||0,o._node.bufferSource.loopEnd=o._stop)));return d},/**
         * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   rate() -> Returns the first sound node's current playback rate.
         *   rate(id) -> Returns the sound id's current playback rate.
         *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
         *   rate(rate, id) -> Sets the playback rate of passed sound id.
         * @return {Howl/Number} Returns self or the current playback rate.
         */rate:function(){var e,o,d=this,t=arguments;// Determine the values based on arguments.
if(0===t.length)// We will simply return the current rate of the first node.
o=d._sounds[0]._id;else if(1===t.length){// First check if this is an ID, and if not, assume it is a new rate value.
var _=d._getSoundIds(),u=_.indexOf(t[0]);0<=u?o=parseInt(t[0],10):e=parseFloat(t[0])}else 2===t.length&&(e=parseFloat(t[0]),o=parseInt(t[1],10));// Update the playback rate or return the current value.
var a;if("number"==typeof e){// If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
if("loaded"!==d._state||d._playLock)return d._queue.push({event:"rate",action:function action(){d.rate.apply(d,t)}}),d;// Set the group rate.
"undefined"==typeof o&&(d._rate=e),o=d._getSoundIds(o);for(var r=0;r<o.length;r++)if(a=d._soundById(o[r]),a){d.playing(o[r])&&(a._rateSeek=d.seek(o[r]),a._playStart=d._webAudio?n.ctx.currentTime:a._playStart),a._rate=e,d._webAudio&&a._node&&a._node.bufferSource?a._node.bufferSource.playbackRate.setValueAtTime(e,n.ctx.currentTime):a._node&&(a._node.playbackRate=e);// Reset the timers.
var s=d.seek(o[r]),l=(d._sprite[a._sprite][0]+d._sprite[a._sprite][1])/1e3-s,c=1e3*l/Math.abs(a._rate);(d._endTimers[o[r]]||!a._paused)&&(d._clearTimer(o[r]),d._endTimers[o[r]]=setTimeout(d._ended.bind(d,a),c)),d._emit("rate",a._id)}}else return a=d._soundById(o),a?a._rate:d._rate;return d},/**
         * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   seek() -> Returns the first sound node's current seek position.
         *   seek(id) -> Returns the sound id's current seek position.
         *   seek(seek) -> Sets the seek position of the first sound node.
         *   seek(seek, id) -> Sets the seek position of passed sound id.
         * @return {Howl/Number} Returns self or the current seek position.
         */seek:function(){var e,o,d=this,t=arguments;// Determine the values based on arguments.
if(0===t.length)// We will simply return the current position of the first node.
o=d._sounds[0]._id;else if(1===t.length){// First check if this is an ID, and if not, assume it is a new seek position.
var _=d._getSoundIds(),u=_.indexOf(t[0]);0<=u?o=parseInt(t[0],10):d._sounds.length&&(o=d._sounds[0]._id,e=parseFloat(t[0]))}else 2===t.length&&(e=parseFloat(t[0]),o=parseInt(t[1],10));// If there is no ID, bail out.
if("undefined"==typeof o)return d;// If the sound hasn't loaded, add it to the load queue to seek when capable.
if("loaded"!==d._state||d._playLock)return d._queue.push({event:"seek",action:function action(){d.seek.apply(d,t)}}),d;// Get the sound.
var a=d._soundById(o);if(a)if("number"==typeof e&&0<=e){// Pause the sound and update position for restarting playback.
var i=d.playing(o);i&&d.pause(o,!0),a._seek=e,a._ended=!1,d._clearTimer(o),d._webAudio||!a._node||isNaN(a._node.duration)||(a._node.currentTime=e);// Seek and emit when ready.
var r=function(){d._emit("seek",o),i&&d.play(o,!0)};// Wait for the play lock to be unset before emitting (HTML5 Audio).
if(i&&!d._webAudio){var s=function(){d._playLock?setTimeout(s,0):r()};setTimeout(s,0)}else r()}else{if(d._webAudio){var l=d.playing(o)?n.ctx.currentTime-a._playStart:0,c=a._rateSeek?a._rateSeek-a._seek:0;return a._seek+(c+l*Math.abs(a._rate))}return a._node.currentTime}return d},/**
         * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
         * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
         * @return {Boolean} True if playing and false if not.
         */playing:function playing(e){var n=this;// Check the passed sound ID (if any).
if("number"==typeof e){var o=n._soundById(e);return!!o&&!o._paused}// Otherwise, loop through all sounds and check if any are playing.
for(var d=0;d<n._sounds.length;d++)if(!n._sounds[d]._paused)return!0;return!1},/**
         * Get the duration of this sound. Passing a sound id will return the sprite duration.
         * @param  {Number} id The sound id to check. If none is passed, return full source duration.
         * @return {Number} Audio duration in seconds.
         */duration:function(e){var n=this,o=n._duration,d=n._soundById(e);return d&&(o=n._sprite[d._sprite][1]/1e3),o},/**
         * Returns the current loaded state of this Howl.
         * @return {String} 'unloaded', 'loading', 'loaded'
         */state:function state(){return this._state},/**
         * Unload and destroy the current Howl object.
         * This will immediately stop all sound instances attached to this group.
         */unload:function unload(){for(var e=this,o=e._sounds,d=0;d<o.length;d++)// Empty out all of the nodes.
// Make sure all timers are cleared out.
o[d]._paused||e.stop(o[d]._id),e._webAudio||(e._clearSound(o[d]._node),o[d]._node.removeEventListener("error",o[d]._errorFn,!1),o[d]._node.removeEventListener(n._canPlayEvent,o[d]._loadFn,!1),n._releaseHtml5Audio(o[d]._node)),delete o[d]._node,e._clearTimer(o[d]._id);// Remove the references in the global Howler object.
var _=n._howls.indexOf(e);0<=_&&n._howls.splice(_,1);// Delete this sound from the cache (if no other Howl is using it).
var u=!0;for(d=0;d<n._howls.length;d++)if(n._howls[d]._src===e._src||0<=e._src.indexOf(n._howls[d]._src)){u=!1;break}return t&&u&&delete t[e._src],n.noAudio=!1,e._state="unloaded",e._sounds=[],e=null,null},/**
         * Listen to a custom event.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
         * @return {Howl}
         */on:function on(e,n,o,d){var t=this,_=t["_on"+e];return"function"==typeof n&&_.push(d?{id:o,fn:n,once:d}:{id:o,fn:n}),t},/**
         * Remove a custom event. Call without parameters to remove all events.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to remove. Leave empty to remove all.
         * @param  {Number}   id    (optional) Only remove events for this sound.
         * @return {Howl}
         */off:function off(e,n,o){var d=this,t=d["_on"+e],_=0;if("number"==typeof n&&(o=n,n=null),n||o)// Loop through event store and remove the passed function.
for(_=0;_<t.length;_++){var u=o===t[_].id;if(n===t[_].fn&&u||!n&&u){t.splice(_,1);break}}else if(e)// Clear out all events of this type.
d["_on"+e]=[];else{// Clear out all events of every type.
var a=Object.keys(d);for(_=0;_<a.length;_++)0===a[_].indexOf("_on")&&Array.isArray(d[a[_]])&&(d[a[_]]=[])}return d},/**
         * Listen to a custom event and remove it once fired.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @return {Howl}
         */once:function once(e,n,o){var d=this;// Setup the event listener.
return d.on(e,n,o,1),d},/**
         * Emit all events of a specific type and pass the sound id.
         * @param  {String} event Event name.
         * @param  {Number} id    Sound ID.
         * @param  {Number} msg   Message to go with event.
         * @return {Howl}
         */_emit:function _emit(e,n,o){// Loop through event store and fire all functions.
for(var d=this,t=d["_on"+e],_=t.length-1;0<=_;_--)// Only fire the listener if the correct ID is used.
t[_].id&&t[_].id!==n&&"load"!==e||(setTimeout(function(e){e.call(this,n,o)}.bind(d,t[_].fn),0),t[_].once&&d.off(e,t[_].fn,t[_].id));// Pass the event type into load queue so that it can continue stepping.
return d._loadQueue(e),d},/**
         * Queue of actions initiated before the sound has loaded.
         * These will be called in sequence, with the next only firing
         * after the previous has finished executing (even if async like play).
         * @return {Howl}
         */_loadQueue:function _loadQueue(e){var n=this;if(0<n._queue.length){var o=n._queue[0];// Remove this task if a matching event was passed.
o.event===e&&(n._queue.shift(),n._loadQueue()),e||o.action()}return n},/**
         * Fired when playback ends at the end of the duration.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */_ended:function _ended(e){var o=this,d=e._sprite;// If we are using IE and there was network latency we may be clipping
// audio before it completes playing. Lets check the node to make sure it
// believes it has completed, before ending the playback.
if(!o._webAudio&&e._node&&!e._node.paused&&!e._node.ended&&e._node.currentTime<e._stop)return setTimeout(o._ended.bind(o,e),100),o;// Should this sound loop?
var t=!!(e._loop||o._sprite[d][2]);// Fire the ended event.
// Restart this timer if on a Web Audio loop.
if(o._emit("end",e._id),!o._webAudio&&t&&o.stop(e._id,!0).play(e._id),o._webAudio&&t){o._emit("play",e._id),e._seek=e._start||0,e._rateSeek=0,e._playStart=n.ctx.currentTime;var _=1e3*(e._stop-e._start)/Math.abs(e._rate);o._endTimers[e._id]=setTimeout(o._ended.bind(o,e),_)}// Mark the node as paused.
return o._webAudio&&!t&&(e._paused=!0,e._ended=!0,e._seek=e._start||0,e._rateSeek=0,o._clearTimer(e._id),o._cleanBuffer(e._node),n._autoSuspend()),o._webAudio||t||o.stop(e._id,!0),o},/**
         * Clear the end timer for a sound playback.
         * @param  {Number} id The sound ID.
         * @return {Howl}
         */_clearTimer:function _clearTimer(e){var n=this;if(n._endTimers[e]){// Clear the timeout or remove the ended listener.
if("function"!=typeof n._endTimers[e])clearTimeout(n._endTimers[e]);else{var o=n._soundById(e);o&&o._node&&o._node.removeEventListener("ended",n._endTimers[e],!1)}delete n._endTimers[e]}return n},/**
         * Return the sound identified by this ID, or return null.
         * @param  {Number} id Sound ID
         * @return {Object}    Sound object or null.
         */_soundById:function _soundById(e){// Loop through all sounds and find the one with this ID.
for(var n=this,o=0;o<n._sounds.length;o++)if(e===n._sounds[o]._id)return n._sounds[o];return null},/**
         * Return an inactive sound from the pool or create a new one.
         * @return {Sound} Sound playback object.
         */_inactiveSound:function _inactiveSound(){var e=this;e._drain();// Find the first inactive node to recycle.
for(var n=0;n<e._sounds.length;n++)if(e._sounds[n]._ended)return e._sounds[n].reset();// If no inactive node was found, create a new one.
return new d(e)},/**
         * Drain excess inactive sounds from the pool.
         */_drain:function _drain(){var e=this,n=e._pool,o=0,d=0;// If there are less sounds than the max pool size, we are done.
if(!(e._sounds.length<n)){// Count the number of inactive sounds.
for(d=0;d<e._sounds.length;d++)e._sounds[d]._ended&&o++;// Remove excess inactive sounds, going in reverse order.
for(d=e._sounds.length-1;0<=d;d--){if(o<=n)return;e._sounds[d]._ended&&(e._webAudio&&e._sounds[d]._node&&e._sounds[d]._node.disconnect(0),e._sounds.splice(d,1),o--)}}},/**
         * Get all ID's from the sounds pool.
         * @param  {Number} id Only return one ID if one is passed.
         * @return {Array}    Array of IDs.
         */_getSoundIds:function _getSoundIds(e){var n=this;if("undefined"==typeof e){for(var o=[],d=0;d<n._sounds.length;d++)o.push(n._sounds[d]._id);return o}return[e]},/**
         * Load the sound back into the buffer source.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */_refreshBuffer:function _refreshBuffer(e){var o=this;// Setup the buffer source for playback.
return e._node.bufferSource=n.ctx.createBufferSource(),e._node.bufferSource.buffer=t[o._src],e._panner?e._node.bufferSource.connect(e._panner):e._node.bufferSource.connect(e._node),e._node.bufferSource.loop=e._loop,e._loop&&(e._node.bufferSource.loopStart=e._start||0,e._node.bufferSource.loopEnd=e._stop||0),e._node.bufferSource.playbackRate.setValueAtTime(e._rate,n.ctx.currentTime),o},/**
         * Prevent memory leaks by cleaning up the buffer source after playback.
         * @param  {Object} node Sound's audio node containing the buffer source.
         * @return {Howl}
         */_cleanBuffer:function _cleanBuffer(e){var o=this,d=n._navigator&&0<=n._navigator.vendor.indexOf("Apple");if(n._scratchBuffer&&e.bufferSource&&(e.bufferSource.onended=null,e.bufferSource.disconnect(0),d))try{e.bufferSource.buffer=n._scratchBuffer}catch(n){}return e.bufferSource=null,o},/**
         * Set the source to a 0-second silence to stop any downloading (except in IE).
         * @param  {Object} node Audio node to clear.
         */_clearSound:function _clearSound(e){var o=/MSIE |Trident\//.test(n._navigator&&n._navigator.userAgent);o||(e.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")}};/** Single Sound Methods **/ /***************************************************************************/ /**
     * Setup the sound object, which each node attached to a Howl group is contained in.
     * @param {Object} howl The Howl parent group.
     */var d=function(e){this._parent=e,this.init()};d.prototype={/**
         * Initialize a new Sound object.
         * @return {Sound}
         */init:function init(){var e=this,o=e._parent;return e._muted=o._muted,e._loop=o._loop,e._volume=o._volume,e._rate=o._rate,e._seek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,o._sounds.push(e),e.create(),e},/**
         * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
         * @return {Sound}
         */create:function create(){var e=this,o=e._parent,d=n._muted||e._muted||e._parent._muted?0:e._volume;return o._webAudio?(e._node="undefined"==typeof n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),e._node.gain.setValueAtTime(d,n.ctx.currentTime),e._node.paused=!0,e._node.connect(n.masterGain)):!n.noAudio&&(e._node=n._obtainHtml5Audio(),e._errorFn=e._errorListener.bind(e),e._node.addEventListener("error",e._errorFn,!1),e._node.crossOrigin="http://localhost:9000",e._loadFn=e._loadListener.bind(e),e._node.addEventListener(n._canPlayEvent,e._loadFn,!1),e._node.src=o._src,e._node.preload="auto",e._node.volume=d*n.volume(),e._node.load()),e},/**
         * Reset the parameters of this sound to the original state (for recycle).
         * @return {Sound}
         */reset:function reset(){var e=this,o=e._parent;return e._muted=o._muted,e._loop=o._loop,e._volume=o._volume,e._rate=o._rate,e._seek=0,e._rateSeek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,e},/**
         * HTML5 Audio error listener callback.
         */_errorListener:function _errorListener(){var e=this;// Fire an error event and pass back the code.
// Clear the event listener.
e._parent._emit("loaderror",e._id,e._node.error?e._node.error.code:0),e._node.removeEventListener("error",e._errorFn,!1)},/**
         * HTML5 Audio canplaythrough listener callback.
         */_loadListener:function _loadListener(){var e=this,o=e._parent;// Round up the duration to account for the lower precision in HTML5 Audio.
// Clear the event listener.
o._duration=Math.ceil(10*e._node.duration)/10,0===Object.keys(o._sprite).length&&(o._sprite={__default:[0,1e3*o._duration]}),"loaded"!==o._state&&(o._state="loaded",o._emit("load"),o._loadQueue()),e._node.removeEventListener(n._canPlayEvent,e._loadFn,!1)}};/** Helper Methods **/ /***************************************************************************/var t={},_=function(e){var n=e._src;// Check if the buffer has already been cached and use it instead.
if(t[n])return e._duration=t[n].duration,void r(e);if(/^data:[^;]+;base64,/.test(n)){// Decode the base64 data URI without XHR, since some browsers don't support it.
for(var o=atob(n.split(",")[1]),d=new Uint8Array(o.length),_=0;_<o.length;++_)d[_]=o.charCodeAt(_);a(d.buffer,e)}else{// Load the buffer from the URL.
var s=new XMLHttpRequest;s.open("GET",n,!0),s.withCredentials=e._xhrWithCredentials,s.responseType="arraybuffer",s.onload=function(){// Make sure we get a successful response back.
var n=(s.status+"")[0];return"0"!==n&&"2"!==n&&"3"!==n?void e._emit("loaderror",null,"Failed loading audio file with status: "+s.status+"."):void a(s.response,e)},s.onerror=function(){e._webAudio&&(e._html5=!0,e._webAudio=!1,e._sounds=[],delete t[n],e.load())},u(s)}},u=function(n){try{n.send()}catch(o){n.onerror()}},a=function(e,o){// Fire a load error if something broke.
var d=function(){o._emit("loaderror",null,"Decoding audio data failed.")},_=function(e){e&&0<o._sounds.length?(t[o._src]=e,r(o,e)):d()};// Load the sound on success.
"undefined"!=typeof Promise&&1===n.ctx.decodeAudioData.length?n.ctx.decodeAudioData(e).then(_)["catch"](d):n.ctx.decodeAudioData(e,_,d)},r=function(e,n){n&&!e._duration&&(e._duration=n.duration),0===Object.keys(e._sprite).length&&(e._sprite={__default:[0,1e3*e._duration]}),"loaded"!==e._state&&(e._state="loaded",e._emit("load"),e._loadQueue())},s=function(){// If we have already detected that Web Audio isn't supported, don't run this step again.
if(n.usingWebAudio){// Check if we are using Web Audio and setup the AudioContext if we are.
try{"undefined"==typeof AudioContext?"undefined"==typeof webkitAudioContext?n.usingWebAudio=!1:n.ctx=new webkitAudioContext:n.ctx=new AudioContext}catch(o){n.usingWebAudio=!1}// If the audio context creation still failed, set using web audio to false.
n.ctx||(n.usingWebAudio=!1);// Check if a webview is being used on iOS8 or earlier (rather than the browser).
// If it is, disable Web Audio as it causes crashing.
var e=/iP(hone|od|ad)/.test(n._navigator&&n._navigator.platform),o=n._navigator&&n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),d=o?parseInt(o[1],10):null;if(e&&d&&9>d){var t=/safari/.test(n._navigator&&n._navigator.userAgent.toLowerCase());(n._navigator&&n._navigator.standalone&&!t||n._navigator&&!n._navigator.standalone&&!t)&&(n.usingWebAudio=!1)}// Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
n.usingWebAudio&&(n.masterGain="undefined"==typeof n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),n.masterGain.gain.setValueAtTime(n._muted?0:n._volume,n.ctx.currentTime),n.masterGain.connect(n.ctx.destination)),n._setup()}};/**
     * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
     * @param  {Howl} self
     */"function"==typeof define&&define.amd&&define([],function(){return{Howler:n,Howl:o}}),"undefined"!=typeof exports&&(exports.Howler=n,exports.Howl=o),"undefined"==typeof window?"undefined"!=typeof global&&(global.HowlerGlobal=e,global.Howler=n,global.Howl=o,global.Sound=d):(window.HowlerGlobal=e,window.Howler=n,window.Howl=o,window.Sound=d)})();